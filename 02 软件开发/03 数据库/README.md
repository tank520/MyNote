# 事务

## 隔离级别

### read uncommitted(读未提交)

能读到其它事务未提交的内容，会产生脏读。

### read committed(读提交)

一个事物从开始到提交之前，对其它事务都是不可见的。也叫作`nonrepeatable read`(不可重复读)

### repeatable read(可重复读)

事务中相同的查询，其结构始终是一样的。解决了*不可重复读*的问题，但是可能会读取到其它事务新增的数据，导致**幻读**。

Mysql的默认隔离级别。

### serializable(串行化)

强制事务串行执行，严重影响了并发性能。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTEd | Y    | Y          | Y    | N      |
| READ COMMITTED   | N    | Y          | Y    | N      |
| REPEATABLE READ  | N    | N          | Y    | N      |
| SERIALIZABLE     | N    | N          | N    | Y      |

## MVCC

​        MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。 基于提升并发性能的考虑， 它们一般都同时实现了多版本并发控制（MVCC） 。 不仅是MySQL， 包括Oracle、 PostgreSQL等其他数据库系统也都实现了MVCC， 但各自的实现机制不尽相同， 因为MVCC没有一个统一的实现标准。

可以认为MVCC是行级锁的一个变种， 但是它在很多情况下避免了加锁操作， 因此开销更低。 虽然实现机制有所不同， 但大都实现了非阻塞的读操作， 写操作也只锁定必要的行。

MVCC的实现， 是通过保存数据在某个时间点的快照来实现的。 也就是说， 不管需要执行多长时间， 每个事务看到的数据都是一致的。 根据事务开始的时间不同， 每个事务对同一张表， 同一时刻看到的数据可能是不一样的。

InnoDB的MVCC， 是通过在每行记录后面保存两个隐藏的列来实现的。 这两个列， 一个保存了行的创建时间， 一个保存行的过期时间（或删除时间） 。 当然存储的并不是实际的时间值， 而是系统版本号（system version number） 。 每开始一个新的事务， 系统版本号都会自动递增。 事务开始时刻的系统版本号会作为事务的版本号， 用来和查询到的每行记录的版本号进行比较。 

1. MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。

2. Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。

   原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。

3. 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

4. MVCC主要作用于事务性的，有行锁控制的数据库模型。

# 索引

## 类别

### 独立的列

### 前缀索引和索引选择性

​        索引的选择性是指， 不重复的索引值（也称为基数， cardinality） 和数据表的记录总数（#T）的比值， 范围从1/#T到1之间。 索引的选择性越高则查询效率越高， 因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。 唯一索引的选择性是1， 这是最好的索引选择性， 性能也是最好的。  

### 多列索引

### 索引列顺序

​        将选择性最高的列放到索引最前列。  

### 聚簇索引

### 覆盖索引

​        索引的叶子节点中已经包含要查询的数据 

### 索引扫描排序

​        如果`WHERE` 子句或者`JOIN` 子句中对索引中的前列指定了常量，   则可以利用索引排序。

### 压缩索引

### 索引和锁

InnoDB在二级索引上使用共享（读） 锁， 但访问主键索引需要排他（写） 锁。 这消除了使用覆盖索引的可能性， 并且使得SELECT FOR UPDATE 比LOCK IN SHARE MODE 或非锁定查询要慢很多。  

## 索引优化

在选择索引和编写利用这些索引的查询时， 有如下三个原则始终需要记住：

1. 单行访问是很慢的。 特别是在机械硬盘存储中（SSD的随机I/O要快很多， 不过这一点仍然成立） 。 如果服务器从存储中读取一个数据块只是为了获取其中一行， 那么就浪费了很多工作。 最好读取的块中能包含尽可能多所需要的行。 使用索引可以创建位置引用以提升效率。
2. 按顺序访问范围数据是很快的， 这有两个原因。 第一， 顺序I/O不需要多次磁盘寻道， 所以比随机I/O要快很多（特别是对机械硬盘） 。 第二， 如果服务器能够按需要顺序读取数据， 那么就不再需要额外的排序操作， 并且GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。
3. 索引覆盖查询是很快的。 如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。 这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。  

编写查询语句时应该尽可能选择合适的索引以避免单行查找、 尽可能地使用数据原生顺序从而避免额外的排序操作， 并尽可能使用索引覆盖查询。  

# SQL执行

## 执行过程

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存， 如果命中了缓存， 则立刻返回存储在缓存
   中的结果。 否则进入下一阶段。
3. 服务器端进行SQL解析、 预处理， 再由优化器生成对应的执行计
   划。
4. MySQL根据优化器生成的执行计划， 调用存储引擎的API来执行查
   询。
5. 将结果返回给客户端。  

## 执行状态

### Sleep

线程正在等待客户端发送新的请求。

### Query

线程正在执行查询或者正在将结果发送给客户端。

### Locked

在MySQL服务器层， 该线程正在等待表锁。 在存储引擎级别实现的锁， 例如InnoDB的行锁， 并不会体现在线程状态中。 对于MyISAM来说这是一个比较典型的状态， 但在其他没有行锁的引擎中也经常会出现。

### Analyzing and statistics

线程正在收集存储引擎的统计信息， 并生成查询的执行计划。

### Copying to tmp table [on disk]

线程正在执行查询， 并且将其结果集都复制到一个临时表中，这种状态一般要么是在做GROUP BY 操作， 要么是文件排序操作，或者是UNION操作。 如果这个状态后面还有“on disk”标记， 那表示
MySQL正在将一个内存临时表放到磁盘上。

### The thread is

线程正在对结果集进行排序。

### Sending data

这表示多种情况： 线程可能在多个状态之间传送数据， 或者在生成结果集， 或者在向客户端返回数据。  

# SQL优化

## 硬件优化

## Mysql服务器优化

## SQL语句优化

### explain

```sql
1. ID：执行查询的序列号；
2. select_type：使用的查询类型
    1，DEPENDENT SUBQUERY：子查询中内层的第一个SELECT，依赖于外部查询的结果集；
    2，DEPENDENT UNION：子查询中的UNION，且为UNION 中从第二个SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集；
    3，PRIMARY：子查询中的最外层查询，注意并不是主键查询；
    4，SIMPLE：除子查询或者UNION 之外的其他查询；
    5，SUBQUERY：子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集；
    6，UNCACHEABLE SUBQUERY：结果集无法缓存的子查询；
    7，UNION：UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY
    8，UNION RESULT：UNION 中的合并结果；
3. table：这次查询访问的数据表；
4. type：对表所使用的访问方式：
    1，all：全表扫描
    2，const：读常量，且最多只会有一条记录匹配，由于是常量，所以实际上只需要读一次；
    3，eq_ref：最多只会有一条匹配结果，一般是通过主键或者唯一键索引来访问；
    4，fulltext：全文检索，针对full text索引列；
    5，index：全索引扫描；
    6，index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge 之后再读取表数据；
    7，index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或者唯一索引；
    8，rang：索引范围扫描；
    9，ref：Join 语句中被驱动表索引引用查询；
    10，ref_or_null：与ref 的唯一区别就是在使用索引引用查询之外再增加一个空值的查询；
    11，system：系统表，表中只有一行数据；
    12，unique_subquery：子查询中的返回结果字段组合是主键或者唯一约束；
5. possible_keys：可选的索引；如果没有使用索引，为null；
6. key：最终选择的索引；
7. key_len：被选择的索引长度；
8. ref：过滤的方式，比如const（常量），column（join），func（某个函数）；
9. rows：查询优化器通过收集到的统计信息估算出的查询条数；
10.Extra：查询中每一步实现的额外细节信息
    1，Distinct：查找distinct 值，所以当mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询；
    2，Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用使用；
    3，Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果；
    4，No tables：Query 语句中使用FROM DUAL 或者不包含任何FROM 子句；
    5，Not exists：在某些左连接中MySQL Query Optimizer 所通过改变原有Query 的组成而使用的优化方法，可以部分减少数据访问次数；
    6，Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在Query 中不能有GROUP BY 操作。如使用MIN()或者MAX（）的时候；
    7，Using filesort：当我们的Query 中包含ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。
    8，Using index：所需要的数据只需要在Index 即可全部获得而不需要再到表中取数据；
    9，Using index for group-by：数据访问和Using index 一样，所需数据只需要读取索引即可，而当Query 中使用了GROUP BY 或者DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是Using index for group-by；
    10，Using temporary：当MySQL 在某些操作中必须使用临时表的时候，在Extra 信息中就会出现Using temporary 。主要常见于GROUP BY 和ORDER BY 等操作中。
    11，Using where：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现Using where 信息；
    12，Using where with pushed condition：这是一个仅仅在NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开Condition Pushdown 优化功能才可能会被使用。控制参数为engine_condition_pushdown 。
```



## 反范式优化

## 索引优化