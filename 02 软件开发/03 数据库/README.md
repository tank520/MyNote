# 事务

## 隔离级别

### read uncommitted(读未提交)

能读到其它事务未提交的内容，会产生脏读。

### read committed(读提交)

一个事物从开始到提交之前，对其它事务都是不可见的。也叫作`nonrepeatable read`(不可重复读)

### repeatable read(可重复读)

事务中相同的查询，其结构始终是一样的。解决了*不可重复读*的问题，但是可能会读取到其它事务新增的数据，导致**幻读**。

Mysql的默认隔离级别。

### serializable(串行化)

强制事务串行执行，严重影响了并发性能。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTEd | Y    | Y          | Y    | N      |
| READ COMMITTED   | N    | Y          | Y    | N      |
| REPEATABLE READ  | N    | N          | Y    | N      |
| SERIALIZABLE     | N    | N          | N    | Y      |

## MVCC

​        MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。 基于提升并发性能的考虑， 它们一般都同时实现了多版本并发控制（MVCC） 。 不仅是MySQL， 包括Oracle、 PostgreSQL等其他数据库系统也都实现了MVCC， 但各自的实现机制不尽相同， 因为MVCC没有一个统一的实现标准。

可以认为MVCC是行级锁的一个变种， 但是它在很多情况下避免了加锁操作， 因此开销更低。 虽然实现机制有所不同， 但大都实现了非阻塞的读操作， 写操作也只锁定必要的行。

MVCC的实现， 是通过保存数据在某个时间点的快照来实现的。 也就是说， 不管需要执行多长时间， 每个事务看到的数据都是一致的。 根据事务开始的时间不同， 每个事务对同一张表， 同一时刻看到的数据可能是不一样的。

InnoDB的MVCC， 是通过在每行记录后面保存两个隐藏的列来实现的。 这两个列， 一个保存了行的创建时间， 一个保存行的过期时间（或删除时间） 。 当然存储的并不是实际的时间值， 而是系统版本号（system version number） 。 每开始一个新的事务， 系统版本号都会自动递增。 事务开始时刻的系统版本号会作为事务的版本号， 用来和查询到的每行记录的版本号进行比较。 

1. MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。

2. Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。

   原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。

3. 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

4. MVCC主要作用于事务性的，有行锁控制的数据库模型。