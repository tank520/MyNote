# 事务

## 隔离级别

### read uncommitted(读未提交)

能读到其它事务未提交的内容，会产生脏读。

### read committed(读提交)

一个事物从开始到提交之前，对其它事务都是不可见的。也叫作`nonrepeatable read`(不可重复读)

### repeatable read(可重复读)

事务中相同的查询，其结构始终是一样的。解决了*不可重复读*的问题，但是可能会读取到其它事务新增的数据，导致**幻读**。

Mysql的默认隔离级别。

### serializable(串行化)

强制事务串行执行，严重影响了并发性能。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------- | ---- | ---------- | ---- | ------ |
| READ UNCOMMITTEd | Y    | Y          | Y    | N      |
| READ COMMITTED   | N    | Y          | Y    | N      |
| REPEATABLE READ  | N    | N          | Y    | N      |
| SERIALIZABLE     | N    | N          | N    | Y      |

## MVCC

​        MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。 基于提升并发性能的考虑， 它们一般都同时实现了多版本并发控制（MVCC） 。 不仅是MySQL， 包括Oracle、 PostgreSQL等其他数据库系统也都实现了MVCC， 但各自的实现机制不尽相同， 因为MVCC没有一个统一的实现标准。

可以认为MVCC是行级锁的一个变种， 但是它在很多情况下避免了加锁操作， 因此开销更低。 虽然实现机制有所不同， 但大都实现了非阻塞的读操作， 写操作也只锁定必要的行。

MVCC的实现， 是通过保存数据在某个时间点的快照来实现的。 也就是说， 不管需要执行多长时间， 每个事务看到的数据都是一致的。 根据事务开始的时间不同， 每个事务对同一张表， 同一时刻看到的数据可能是不一样的。

InnoDB的MVCC， 是通过在每行记录后面保存两个隐藏的列来实现的。 这两个列， 一个保存了行的创建时间， 一个保存行的过期时间（或删除时间） 。 当然存储的并不是实际的时间值， 而是系统版本号（system version number） 。 每开始一个新的事务， 系统版本号都会自动递增。 事务开始时刻的系统版本号会作为事务的版本号， 用来和查询到的每行记录的版本号进行比较。 

1. MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。

2. Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC。

   原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。

3. 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。

4. MVCC主要作用于事务性的，有行锁控制的数据库模型。

# 索引

## 类别

### 独立的列

### 前缀索引和索引选择性

​        索引的选择性是指， 不重复的索引值（也称为基数， cardinality） 和数据表的记录总数（#T）的比值， 范围从1/#T到1之间。 索引的选择性越高则查询效率越高， 因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。 唯一索引的选择性是1， 这是最好的索引选择性， 性能也是最好的。  

### 多列索引

### 索引列顺序

​        将选择性最高的列放到索引最前列。  

### 聚簇索引

### 覆盖索引

​        索引的叶子节点中已经包含要查询的数据 

### 索引扫描排序

​        如果`WHERE` 子句或者`JOIN` 子句中对索引中的前列指定了常量，   则可以利用索引排序。

### 压缩索引

### 索引和锁

InnoDB在二级索引上使用共享（读） 锁， 但访问主键索引需要排他（写） 锁。 这消除了使用覆盖索引的可能性， 并且使得SELECT FOR UPDATE 比LOCK IN SHARE MODE 或非锁定查询要慢很多。  

## 优化

在选择索引和编写利用这些索引的查询时， 有如下三个原则始终需要记住：

1. 单行访问是很慢的。 特别是在机械硬盘存储中（SSD的随机I/O要快很多， 不过这一点仍然成立） 。 如果服务器从存储中读取一个数据块只是为了获取其中一行， 那么就浪费了很多工作。 最好读取的块中能包含尽可能多所需要的行。 使用索引可以创建位置引用以提升效率。
2. 按顺序访问范围数据是很快的， 这有两个原因。 第一， 顺序I/O不需要多次磁盘寻道， 所以比随机I/O要快很多（特别是对机械硬盘） 。 第二， 如果服务器能够按需要顺序读取数据， 那么就不再需要额外的排序操作， 并且GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。
3. 索引覆盖查询是很快的。 如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。 这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。  

编写查询语句时应该尽可能选择合适的索引以避免单行查找、 尽可能地使用数据原生顺序从而避免额外的排序操作， 并尽可能使用索引覆盖查询。  

# SQL执行

## 执行过程

1. 客户端发送一条查询给服务器。
2. 服务器先检查查询缓存， 如果命中了缓存， 则立刻返回存储在缓存
   中的结果。 否则进入下一阶段。
3. 服务器端进行SQL解析、 预处理， 再由优化器生成对应的执行计
   划。
4. MySQL根据优化器生成的执行计划， 调用存储引擎的API来执行查
   询。
5. 将结果返回给客户端。  

## 执行状态

### Sleep

线程正在等待客户端发送新的请求。

### Query

线程正在执行查询或者正在将结果发送给客户端。

### Locked

在MySQL服务器层， 该线程正在等待表锁。 在存储引擎级别实现的锁， 例如InnoDB的行锁， 并不会体现在线程状态中。 对于MyISAM来说这是一个比较典型的状态， 但在其他没有行锁的引擎中也经常会出现。

### Analyzing and statistics

线程正在收集存储引擎的统计信息， 并生成查询的执行计划。

### Copying to tmp table [on disk]

线程正在执行查询， 并且将其结果集都复制到一个临时表中，这种状态一般要么是在做GROUP BY 操作， 要么是文件排序操作，或者是UNION操作。 如果这个状态后面还有“on disk”标记， 那表示
MySQL正在将一个内存临时表放到磁盘上。

### The thread is

线程正在对结果集进行排序。

### Sending data

这表示多种情况： 线程可能在多个状态之间传送数据， 或者在生成结果集， 或者在向客户端返回数据。  