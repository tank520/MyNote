## 特性

### doublewrite

为了解决在数据库宕机时，InnoDB存储引擎可能正在写入某个页且只写了一部分，这种情况下会出现写失效的问题，尽管可以通过重做日志恢复，但如果页本身发生损坏，则无法进行重做。这时InnoDB引入两次写（doublewrite）来解决这个问题。

doublewrite由两部分组成：

1、doublewrite buffer

2、共享表空间的两个区（连续的128个页）

在刷新缓冲池中的脏页时，首先将页复制到doublewrite buffer中，然后通过doublewrite buffer分两次顺序地写入共享表空间中的物理磁盘上，然后再同步到数据文件中。这样如果发生意外，则可以从共享表空间当中恢复数据。

![img](https://static.dingtalk.com/media/lALPDe7sw0WVrR3NAhjNA5c_919_536.png_827x10000.jpg?bizType=report) 

## 存储结构

### 行溢出

InnoDB单行最大限制为65535字节，不包括TEXT、Blob。

InnoDB存储引擎页大小为16KB，即16384字节，如何存放65535字节呢？

一般情况下，InnoDB存储引擎的数据都是存放在页类型为B-tree node中，但是当发生行溢出时，数据存放在页类型为Uncompress BLOB页中。

原因：存储引擎表是索引组织的，即B+tree的结构，这样每个页中至少应该有两条行记录（否则失去B+tree的意义，变成链表了）。

## 锁

### 共享/排它锁(Shared and Exclusive Locks)

属于行级锁

共享锁（S）：允许事务同时读，阻止其他事务对该数据进行修改

排他锁（X）：允许某一事务去读取或更新数据，阻止其他事务对数据进行查询或者修改

### 意向锁(Intention Locks)

意向共享锁（IS）：当一个事务要给一条数据加S锁的时候，会先对数据所在的表先加上IS锁，成功后才能加上S锁

意向排它锁（IX）：当一个事务要给一条数据加X锁的时候，会先对数据所在的表先加上IX锁，成功后才能加上X锁

意向锁之间兼容，不会阻塞。但是会跟S锁和X锁冲突，冲突的方式跟读写锁相同。

|      | IS   | IX   | S    | X    |
| ---- | ---- | ---- | ---- | ---- |
| IS   | √    | √    | √    | ×    |
| IX   | √    | √    | ×    | ×    |
| S    | √    | ×    | √    | ×    |
| X    | ×    | ×    | ×    | ×    |



### 记录锁(Record Locks)

单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。

### 间隙锁(Gap Locks)

在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题，关于幻读的演示和gap锁如何解决了幻读。

### 临键锁(Next-key Locks)

Record Locks + Next-key Locks

### 插入意向锁(Insert Intention Locks)

插入意向锁在行插入之前由INSERT设置一种间隙锁，是意向排它锁的一种。

### 自增锁(Auto-inc Locks)

表级锁

当一张表的某个字段是自增列时，innodb会在该索引的末位加一个排它锁。

但是锁定仅仅持续到当前SQL语句的末尾，而不是整个事务的结束。