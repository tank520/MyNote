# 字节码和类加载器

## 字节码

### 字节码技术

​		Java字节码增强指的是在Java字节码生成之后，对其进行修改，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。Java字节码增强主要是为了减少冗余代码，提高性能等。

实现字节码增强的主要步骤为：

1. 修改字节码

   ​		在内存中获取到原来的字节码，然后通过一些工具（如 ASM，Javaasist）来修改它的byte[]数组，得到一个新的byte数组。

2. 使修改后的字节码生效

   有两种方法：

   1. 自定义ClassLoader来加载修改后的字节码；
   2. 替换掉原来的字节码：在JVM加载用户的Class时，拦截，返回修改后的字节码；或者在运行时，使用Instrumentation.redefineClasses方法来替换掉原来的字节码

### 字节码操作类库

1. BCEL

   ​		Byte Code Engineering Library(BCEL)，这是Apache Software Foundation的Jakarta项目的一部分。BCEL是Java classworking 广泛使用的一种框架，它可以让您深入jvm汇编语言进行类库操作的细节。BCEL与javassist有不同的处理字节码方法，BCEL在实际的jvm指令层次上进行操作(BCEL拥有丰富的jvm指令集支持) 而javassist所强调的是源代码级别的工作。

2. ASM

   是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令。

   高性能，高质量。

3. Cglib

   生成类库，基于ASM实现。

4. javaassist

   是一个开源的分析，编辑和创建Java字节码的类库。性能较ASM差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。

   * 优点

     1. 比反射开销小，性能高。

     2. javassist性能高于反射，低于ASM

     3. 运行时操作字节码可以让我们实现如下功能：

        动态生成新的类

        动态改变某个类的结构 ( 添加 / 删除 / 修改  新的属性 / 方法 )

   * 缺点

     1. 不支持数组的初始化，如 String[]{"1","2"} ，除非只有数组的容量为 1

     2.  不支持内部类和匿名类

     3.  不支持 continue 和 break表达式

     4.  对于继承关系，有些不支持

        

## 类加载器

### 类加载步骤

1. 加载(Loading)

   ​		将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口，这个过程需要类加载器参与。

2. 验证(Verification)

   确保加载的类信息符合JVM规范，没有安全方面的问题。

3. 准备(Preparation)

   正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

4. 解析(Resolution)

   虚拟机常量池的符号引用替换为字节引用过程。

5. 初始化(Initialization)

   初始化阶段是执行类构造器<clinit>（）方法的过程。类构造器<clinit>（）方法是由编译器自动收藏类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生，代码从上往下执行。

   当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

   ***虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确加锁和同步。***

### 双亲委派模型

#### 定义

​		如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。

#### 优点

1. Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次
2. 考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改

### 类加载器常用方法

#### 	loadClass(String)

#### 	findClass(String)

#### 	defineClass(byte[] b, int off, int len)

#### 	resolveClass(Class<?> c)



### 热部署

​		在类加载器中，java类只能被加载一次，并且无法卸载。

#### 步骤

1. 销毁该自定义ClassLoader
2. 更新class类文件
3. 创建新的ClassLoader去加载更新后的class类文件。

#### 热部署与热加载区别

1. 热部署在服务器运行时重新部署项目，热部署直接重新加载整个应用，更多的是在生产环境使用
2. 热加载在运行时重新加载class，热加载在运行时重新加载class，更多的实在开发环境使用