## 序列化

1. ID问题

   虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致。

2. 静态变量序列化

   序列化保存的是对象的状态，静态变量属于类的状态，因此***序列化并不保存静态变量***。

3. 父类的序列化与Transient关键字

   ***要想将父类对象也序列化，就需要让父类也实现Serializable 接口***。如果父类不实现的话的，就 ***需要有默认的无参的构造函数***。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。

4. 对敏感字段加密

   在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。

5. 序列化存储规则

   Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。