## Redis

### 数据类型

#### 字符串

​	可以存储字符串、整数或者浮点数。

​	常用命令：`GET`（获取key对应的值）、`SET`（设置key对应的值）、`DEL`（删除key和值）

#### 列表

​	常用命令：`LPUSH`和`RPUSH`（将元素推入链表的左端和右端）、`LPOP`和`RPOP`（从链表的左端和右端弹出元素）、`LINDEX`（获取链表在指定位置上的一个元素）、`LRANG`（获取链表在指定范围的元素）

#### 集合

​	常用命令：`SADD`（将元素添加到集合）、`SREM`（将元素从集合中移除）、`SISMEMBER`（快速检查一个元素是否存在于集合中）、`SMEMBERS`（获取集合包含的所有元素）、`SINTER`（交集计算）、`SUNION`（并集计算）、`SDIFF`（差集计算）

#### 有序集合

​	常用命令：`ZADD`（将指定分值的成员添加到有序集合）、`ZRANGE`（根据元素在有序集合中的位置，从有序集合中获取多个元素）、`ZRANGEBYSCORE`（获取有序集合在给定分值范围内的所有元素）、`ZREM`（从有序集合中移除成员）

#### 哈希表

​	包含键值对的无序散列表，和字符串一样，散列存储的值既可以是字符串，又可以是数字值，并且可以对数字值执行自增、自减操作.

​	常用命令：`HSET`（在散列表中设置键值对）、`HGET`（在散列表中获取指定键的值）、`HGETALL`（获取散列表所有的键值对）、`HDEL`（从散列表中删除键值对）

### 数据结构

#### 简单动态字符串

​	redis底层所有字符串都使用的是简单动态字符串，具有如下三个特性：

1. 可以高效执行长度计算
2. 可以高效执行追加操作
3. 二进制安全（程序不对字符串里保存的数据做任何假设，数据可以是以\0结尾的C字符串、也可以是单纯的字节数组，或者其他格式的数据）

```c
struct sdshdr {
    int len;  // buf已使用长度    

    int free;  //buf剩余可用长度

    char buf[];  //实际保存字符串数据的地方
}
```

#### 双端链表

​	普通的双向链表

#### hash表

```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
```

```c
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

其中`table`是一个二维数组指针，里面的每个数组相当于`dictEntry`的列表，类似于`java`的HashMap

#### 字典

```c
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; 
    unsigned long iterators;
} dict;
```

包含2个哈希表，用于哈希表负载过高进行`rehash`的时候才会用到第2个哈希表

##### rehash

​		当哈希表的冲突率过高时链表会很长，这时查询效率就会变低，所以有必要进行哈希表扩展，而如果哈希表存放的键值对很少的时候把size设的很大，又会浪费内存，这时就有必要进行哈希表收缩。这里扩展和收缩的过程，其实就是rehash的过程。

Redis对字典的哈希表进行rehash的步骤如下：

1. 为dict的哈希表ht[1]分配空间，分配的空间大小取决于操作类型和当前键值对数量ht[0].used

    (1)如果是扩展操作，ht[1]的大小为第一个大于等于 `ht[0].used * 2 * 2^n` 的整数

    (2)如果是收缩操作，ht[1]的大小为第一个大于等于`ht[0] * 2^n`的整数

2. 重新计算ht[0]中所有键的哈希值和索引值，将相应的键值对迁移到ht[1]的指定位置中去，需要注意的是，这个过程是渐进式完成的，不然如果字典很大的话全部迁移完需要一定的时间，这段时间内Redis服务器就不可用了哟

3. 当ht[0]的所有键值对都迁移到ht[1]中去后（此时ht[0]会变成空表），把ht[1]设置为ht[0]，并重新在ht[1]上新建一个空表，为下次rehash做准备

渐进的过程具体如下：

1. 为ht[1]分配空间，此时字典同时持有ht[0]和ht[1]
2. 将rehashidx设为0，表示rehash正式开始
3. 在rehash期间，每次对字典执行任意操作时，程序除了执行对应操作之外，还会顺带将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]，操作完后将rehashidx的值加一
4. 在rehash期间，对字典进行ht[0].size次操作之后，rehashidx的值会增加到ht[0].size，此时ht[0]的所有键值对都已经迁移到ht[1]了，程序会将rehashidx重新置为-1，以此表示rehash完成

Redis在什么条件下会对哈希表进行扩展或收缩：

1. 服务器当前没有在执行`BGSAVE`或`BGREWRITEAOF`命令且哈希表的负载因子大于等于1时进行扩展操作

2. 服务器正在执行`BGSAVE`或`BGREWRITEAOF`命令且哈希表的负载因子大于等于5时进行扩展操作

   （这里负载因子的计算公式为：负载因子 = 哈希表当前保存节点数 / 哈希表大小，而之所以在服务器进行`BGSAVE`或`BGREWRITEAOF`的时候负载因子比较大才进行扩展操作是因为此时Redis会创建子进程，而大多数操作系统采取了写时复制的技术来优化子进程使用效率，不适合在这种时候会做大规模的数据迁移活动，说白了就是为了节约内存和提升效率）

3. 当前负载因子小于0.1时进行收缩操作

#### 跳表

​	跳表从高层索引开始，向下层层查找，可以在对数时间复杂度下完成查找、添加、删除操作。跳表最底层链表是按数据从小到大排序的，因此跳表可以非常方便的进行范围查找。

```c
typedef  struct  zskiplistNode {

    robj *obj; // member对象

    double score;  // 分值

    struct  zskiplistNode *backward; // 后退指针

    struct  zskiplistLevel {  // 层

        struct  zskiplistNode * forward; // 前进指针

        unsigned  int  span;  // 层跨越的节点数量

    }level[];

}zskiplistNode;
```

跳表索引动态更新：当我们不停的向跳表中添加数据，如果不更新索引，就有可能出现两个节点之间数据非常多的情况，极端情况下会退化成单链表。跳表通过随机函数来维持平衡性，当我们向跳表中插入数据时，可以选择同时将这个数据插入到部分索引层，通过随机函数来确定将这个节点插入到哪几层索引中，如果随机函数生成k，就将此节点插入第一层到第k层这k层索引中

#### 整数集合

```c
typedef  struct intset {

    uint32_t   encoding; // 元素使用的类型长度

    uint32_t   length; // 元素个数

    int8_t   contents[]; // 保存元素的数组

}intset;
```

contents数组有以下两个特性：1 没有重复元素 2 元素在数组中从小到大排列

#### 压缩列表

​	[参考](https://www.cnblogs.com/hunternet/p/11306690.html)

​	压缩列表是Redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结枃。一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值。

### QS

#### 1. 为什么采用整数集合、压缩列表

整数集合、压缩列表采用了时间换空间的策略，时间复杂度变高了，但是内存节省了。

整数集合、字典占用内存比较：字典需要存储两个hash table、每个hash table需要存储bulket和entry，每个entry中既有key、又有value、又有next指针，而整数集合中只需存储key。

压缩列表、双向链表、字典、跳表占用内存比较：压缩列表pre_entry_length最多占用5字节、econding和length最多占用5字节。双向链表64位系统pre和next指针各占8字节。字典上边已分析，需要更多的额外内存。跳表需要双向链表和额外的层。这三个都比压缩列表占用更多的内存。

#### 2.为什么redis性能高

1. 完全基于内存，绝大部分请求是内存操作

2. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗

3. 使用多路I/O复用模型（epoll），非阻塞IO

4. 底层高效的数据结构

### Redis事务

​		当客户端处于非事务状态下时，所有发送给服务器端的命令都会立即被服务器执行。但是，当客户端进入事务状态后（`MULTI`命令后进入事务状态），服务器在收到来自客户端的命令时，不会立即执行命令，而是将这些命令全部放进一个事务队列里，然后返回`QUEUED`，表示命令已入队。

当执行`EXEC`命令时，服务器根据客户端所保存的事务队列，以先进先出的方式执行事务队列中的命令。

`DISCARD`命令用于取消一个事务，清空客户端的整个事务队列，将客户端从事务状态调整回非事务状态。

`WATCH`命令只能在客户端进入事务状态前执行，在事务状态下执行WATCH会引发一个错误。`WATCH`命令用于在事务开始之前监听任意数量的键，当调用EXEC命令执行事务时，如果任意一个被监视的键被其他客户端修改了，整个事务不再执行，返回失败。

### REDIS数据持久化

​		redis运行时，数据维持在内存中，为了让这些数据在redis重启之后仍然可用，redis提供了rdb和aof两种持久化模式。

#### rdb

rdb程序将当前内存中的数据库数据库快照保存到磁盘文件中，redis启动时，rdb程序可以通过载入rdb文件来恢复数据库。rdbSave用于生成rdb文件到磁盘，rdbLoad用于将rdb文件中的数据重新载入内存

`SAVE`命令会直接调用`rdbSave`函数，阻塞redis主进程，直到保存完成为止。主进程阻塞期间，服务器不能处理客户端的任何请求。

`BGSAVE`命令会fork一个子进程，子进程调用`rdbSave`生成rdb文件

优点：rdb对于文件备份和灾难恢复来说是个不错的选择，如果数据集比较大，采用rdb进行恢复的效率会更高

缺点：系统在定时持久化之前宕机，没来及写入磁盘的数据都将丢失

#### aof

aof以协议文本的方式，将所有对数据库进行过写入的命令及其参数记录到aof文件

aof有三种保存模式：不保存、每一秒钟保存一次、每执行一个命令保存一次

优点：数据安全性更高

缺点：对于相同数量的数据集，aof文件的大小比rdb文件大，数据恢复时间比rdb长。运行效率比rdb低

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行`save`的时候，再做备份（rdb）

### redis缓存和数据库双写一致性问题

**只能保证最终一致性，强一致性的数据不能放缓存**

读操作：先读缓存，缓存没有的话，读数据库，然后将从数据库中读出的数据放入缓存

更新操作：

1. 先更新数据库，然后删除缓存，待下次读取时更新缓存（更新数据频繁、读取数据不频繁场景），删除缓存可能会失败，可以增加一个消息队列进行补偿

2. 先更新数据库，然后更新缓存，下次读取时读到最新的数据（更新跟读取一样频繁的场景），更新缓存可能会失败，可以增加一个消息队列进行补偿

### redis过期策略和内存淘汰机制

**过期策略**：定期删除+惰性删除

定期删除：redis每隔100ms随机抽取部分key进行检查，如果有过期的key，将过期的key删除

惰性删除：在读取某个key的时候，redis会检查这个key是否设置了过期时间，是否超时，如果超时，将这个key删除

**内存淘汰机制**：如果定期删除没有删除key，也没有读取key进行惰性删除，那么内存使用会越来越高。需要进行内存淘汰。内存淘汰可选配置：

**noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。

**allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用。

**allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。

**volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。

**volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。

**volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。

如果key没有设置 expire ，那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致

### 缓存穿透

​		黑客查询一个一定不存在的数据，这个不存在的数据每次请求都到数据库查询，造成数据库压力

解决方法：

1. 如果查询的数据不存在，仍然把这个空结果进行缓存，但设置一个比较短的过期时间，最长不超过5分钟

2. 采用布隆过滤器，在控制层先进行校验，不存在直接丢弃

   [详解布隆过滤器的原理、使用场景和注意事项 - 简书](https://www.jianshu.com/p/2104d11ee0a2)

### 缓存雪崩

​		同一时间，缓存大面积失效，大量的查询都请求到数据库，造成缓存雪崩

解决方法：

1. 不同的key，缓存失效时间加个随机值，设置不同的过期时间

2. 缓存失效后，通过锁或者队列来控制读数据库写缓存线程的数量

3. 二级缓存，两个缓存设置不同的过期时间。比如缓存A设置为短期，缓存B设置为长期

### 缓存击穿

​		缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

   解决方法：

1. 设置热点数据永远不过期。
2. 限流

**缓存击穿和缓存雪崩的区别在于：雪崩针对很多 key，而击穿只针对于某一个热点 key。**

### 缓存预热

​		缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求时先查询数据库

### 线上如何获取redis所有的keys

`keys`命令可以获取redis所有的key

`smembers`命令可以获取集合所有的元素

在一个大的线上数据系统中，使用`keys`、`smembers`可能会造成阻塞

可以用下边四个scan命令来代替：

[SCAN](https://links.jianshu.com/go?to=http%3A%2F%2Fredisdoc.com%2Fkey%2Fscan.html%23scan)命令用于迭代当前数据库中的数据库键。

[SSCAN](https://links.jianshu.com/go?to=http%3A%2F%2Fredisdoc.com%2Fset%2Fsscan.html%23sscan)命令用于迭代集合键中的元素。

[HSCAN](https://links.jianshu.com/go?to=http%3A%2F%2Fredisdoc.com%2Fhash%2Fhscan.html%23hscan)命令用于迭代哈希键中的键值对。

[ZSCAN](https://links.jianshu.com/go?to=http%3A%2F%2Fredisdoc.com%2Fsorted_set%2Fzscan.html%23zscan)命令用于迭代有序集合中的元素（包括元素成员和元素分值）

### redis常见使用场景

1. 缓存

   缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多

2. 排行榜

   很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。

3. 计数器

   电商网站商品的浏览量、视频网站视频的播放数等都需要计数功能。为了保证数据实时性，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景

4. 分布式会话

   集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。

5. 分布式锁

   在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的`setnx`功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。

6. 社交网络

   点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。

7. 消息队列

   消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。

## Redission

​		[github-wiki]([https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8](https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器))

​		[Redisson](https://redisson.org/)是架设在[Redis](http://redis.cn/)基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。

