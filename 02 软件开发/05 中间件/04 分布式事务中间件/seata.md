# seata

## 三大模块

- TM-TransactionManager事务管理器：定义全局事务的范围，开启、提交或回滚全局事务；
- RM -ResourceManager资源管理器：管理分支事务的资源，注册分支事务到TC，与TC通信反馈分支事务状态，驱动分支事务提交或回滚；
- TC-TransactionCoordinator事务协调器：维护全局和分支事务，驱动全局提交或回滚；

分布式事务流程：

1. TM 请求TC 发起一个全局事务，同时TC生成一个 XID作为全局事务ID.

2. XID将分发给事务调用链上的所有微服务.

3. RM响应全局事务XID向TC注册本地分支事务.

4. TM向TC发出提交或回滚全局事务XID的请求.

5. TC响应全局事务XID，驱动所有分支事务提交或 回滚本地分支事务.

其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起，TC 作为 Seata 的服务端独立部署。

## 模式

### AT

#### 执行阶段

Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

#### 完成阶段

二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据删除，完成数据清理即可。

二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，seata提供了全局锁机制。

#### 写隔离

- **执行阶段** 本地事务提交前，需要确保先拿到 **全局锁** 。
- 拿不到 **全局锁** ，不能提交本地事务。
- 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

#### 核心价值

- **低成本：** **编程模型** 不变，轻依赖 不需要为分布式事务场景做特定设计，业务像搭积木一样自然地构建成长。
- **高性能：**协议 **不阻塞**；资源释放快，保证业务的吞吐。
- **高可用：**极端的异常情况下，可以暂时 **跳过异常事务**，保证整个业务系统的高可用。

#### 适用场景

AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎 0 学习成本。

### TCC

TCC 模式，是指支持把 **自定义** 的分支事务纳入到全局事务的管理中。

TCC 模式，不依赖于底层数据资源的事务支持

- 一阶段 prepare 行为：调用 **自定义** 的 prepare 逻辑。
- 二阶段 commit 行为：调用 **自定义** 的 commit 逻辑。
- 二阶段 rollback 行为：调用 **自定义** 的 rollback 逻辑。

TCC 模式对业务代码有一定的侵入性，但是 TCC 模式无 AT 模式的全局行锁，TCC 性能会比 AT 模式高很多。

#### 适用场景

TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。

#### 缺点

方案落地实现麻烦，业务代码耦合超高。每个需要加事务的地方都都手写这3段代码。

### SEGA